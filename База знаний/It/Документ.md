# Преамбула
Изучал всё из интереса ради, за правильность и достоверность утверждений не ручаюсь. А так было интересно расписать все свои теоретические знания и поглубже разобраться в некоторых моментах)
# Концепции и Парадигмы
## Парадигмы программирования
### Императивный и Декларативный подходы, отличия
Все привычные нам парадигмы делятся на 2 семейства - на Императивные и Декларативные. Для начала, я разберу 2 этих подхода, а уже после перейду к конкретным парадигмам.
#### Императивный подход
При написании отвечает на вопрос "как сделать", "какие манипуляции произвести", программа представляет собой непосредственную последовательность конкретных инструкций. Фильтрация списка в коде будет выглядеть как создание нового списка, итерация по исходному циклу и наполнением нового списка элементами из исходного, если они соответствуют условию.

Пример на C\# (решил взять его для разнообразия)
```cs
// В иперативном стиле, без лишнего сахара, с использованием явного while с counter вместо for или foreach, который здесь был бы в разы уместнее
// Подробнее про объявление переменных в C# ниже
var nums = new int[] {1, 2, 3, 4, 5};
var evenNums = new List<int>();

int i = 0;
while (i < nums.Length)
// итерация по массиву через число-счётчик:
// От 0; Пока меньше длины списка; Увеличить на 1 при каждой итерации
{
	var num = nums[i]; // Получить элемент по индексу i
	if (num % 2 == 0) // Если остаток от деления на 2 == 0
		evenNums.Add(num); // добавить в список чётных чисел
	
	i = i + 1;
}
```

Или преобразования
```csharp
var nums = new List<int>() {1, 2, 3, 4, 5};
var squaredNums = new List<int>();

int i = 0;
while (i < nums.Count)
{	
	squaredNums.Add(nums[i] * nums[i]);
	i = i + 1;
}
```
#### Декларативный подход
Декларативный подход, в отличии от императивного, отвечает на вопрос "что получить", смещение фокуса с преобразований на итоговый результат, "хочу получить список со всеми чётными числами из этого списка".

Тот же пример с фильтрацией списка, на Python
```python
nums = [1, 2, 3, 4, 5]
# filter вернёт объект-итератор
oddNums = list(filter(lambda x: x % 2 == 0, nums))
# Или с использованием сахара
oddNums = [x for x in nums if x % 2 == 0]
```

Пример с преобразованием
```python
nums = [1, 2, 3, 4, 5]
squaredNums = list(map(lambda x: x * x, nums))
# С использованием сахара
squaredNums = [x * x for x in nums]
```

Вместо того, чтобы сказать "как" нам отфильтровать или преобразовать список, мы говорим "что" мы хотим получить - отфильтрованный список, преобразованный список и т.д, это ключевое отличие.

### Процедурная парадигма
Pre-s: Я решил пойти в хронологическом порядке, чтобы при ознакомлении с современными парадигмами было понятно "от куда ноги растут", что, зачем и как было сделано.

> [!warning] Важно
> Я, по понятным причинам, не достаточно хорошо разбираюсь в Процедурной парадигме, поэтому тут может быть бред.
#### Что из себя представляет
Это чистый, императивный стиль, с подходом к организации кода через разбиение основного алгоритма множество отдельных функций и процедур ("подпрограммы"), изменяющих локальные и глобальные состояния программы.
Основными строительными блоками программы являются условные операторы (`if` - `else`), циклы (`for`, `while`, `break` & `continue` в циклах), а также именованные блоки кода, подпрограммы, без и с возвращаемым значением (процедуры и функции).
#### Что такое процедуры и функции, отличия
Начнём с общего: и то, и то - это вынесенный, именованный блок кода без или с входными параметрами.
##### Процедура
Это блок кода, БЕЗ возвращаемого значения. В основном, это либо операция (вывод в консоль, например), либо изменение состояния. Примеры: процедура `print(string)` для записи последовательности байт в буфер вывода консоли (подробнее в блоке "Как работают консольные приложения") с принимаемым аргументом строки и процедура `clearState()` без принимаемых аргументов для сброса некоего состояния.

По определению, процедуры имеют побочные эффекты, так как они меняют состояние. Например, та же процедура `print` меняет состояние памяти (записывает поток байт в буфер вывода консоли). Более простой пример - `deleteEntity(int)` удалит условную сущность, например в БД - изменит состояние, что считается побочным эффектом. Зачастую они НЕ индемподентны, так как множественные вызовы с одинаковыми аргументам НЕ обязательно вернут один и тот же результат. Например, процедура `deleteEntity(int id)` при повторном вызове с тем же id не сможет удалить некую сущность и, скорее всего, вызовет ошибку (в языках с исключениями буквально выбросит ошибку). Индемпотентная процедура будет выглядеть как-нибудь вот так: `setVolume(int)`, повторные вызовы со значением в 500 отработают также, как и первый вызов.

- Процедуры могут возвращать значение, но тут важна сама концепция
##### Функция
Называется так она не просто так, она действительно схожа с математической функцией. В отличии от процедур, функции возвращают некое значение, обычно полученное в результате вычислений на основе переданных аргументов.
###### Чистые функции
Функции также делятся на чистые и не чистые. Чистыми являются функции, не изменяющими состояние, например `add(a, b) => a + b` никогда не изменит состояния в программе, она возвращает результаты вычисления на основе переданных аргументов (на чём строится концепция функционального программирования, о чём ниже). Множественные вызовы этой функции всегда вернут одинаковый результат и ни коем образом не затронут остальной код в программе.

... (потом допишу, тут я какой-то слабый)
#### Проблемы
- Изменяемое глобальное состояние
- Спагетти код
- Побочные эффекты процедур
- Жёсткая связанность кода, сложность рефакторинга, слабая абстракция, как следствие - плохая масштабируемость
### ООП
### ФП